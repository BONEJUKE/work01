# 클라우드 동기화 충돌 해결 전략

다중 기기, 오프라인 편집, 외부 캘린더 가져오기 등으로 인해 동일한 일정/할 일/리마인더가 서로 다른 상태를 가질 수 있습니다. 아래 전략은 Work01 캘린더가 서버 동기화 파이프라인을 도입할 때 따를 기본 정책입니다.

## 1. 데이터 우선순위 계층
1. **사용자 명시 수정(로컬)** – 기기에서 사용자가 직접 편집/완료/삭제한 변경 사항은 항상 서버/타 기기 변경보다 우선합니다. 충돌 시 로컬 변경을 즉시 서버로 푸시하고, 서버 값은 히스토리에 백업합니다.
2. **서버 권장 상태** – 서버는 최신 타임스탬프 기반의 권장 상태를 내려줍니다. 로컬에서 항목이 편집 중이 아니고 최근 5분 내 변경 기록이 없다면 서버 값을 그대로 반영합니다.
3. **외부 소스(캘린더 가져오기)** – 읽기 전용으로 취급하며, 동기화 시점에 새 항목을 병합하거나 삭제된 항목을 숨김 처리합니다. 외부 소스 값이 로컬 편집과 충돌하는 경우 사용자에게 충돌 다이얼로그를 노출합니다.

## 2. 충돌 감지
- 각 항목(Task/Event/Reminder)에 **`updatedAt` 타임스탬프와 변경 주체(origin)** 메타데이터를 부여합니다.
- 동기화 시 동일 ID의 항목이 존재하고 타임스탬프가 다르면 충돌 후보로 분류합니다.
- 리마인더는 `minutesBefore`·`allowSnooze` 구성 목록을 해시하여 변경 여부를 감지합니다.

## 3. 해결 정책
- **동일 필드 동시 변경**: 로컬이 사용자 편집으로 표시되면 로컬 승리, 서버 값은 변경 로그에 보존하고 `AgendaUserMessage.ConflictResolved`로 사용자에게 알립니다.
- **서버 변경만 존재**: 로컬에서 편집 기록이 없으면 서버 값을 수용하고 변경 히스토리를 업데이트합니다.
- **삭제 vs 편집**: 서버가 삭제했지만 로컬이 편집했다면, 항목을 `archived` 상태로 두고 사용자에게 복원/삭제 중 선택하도록 합니다.
- **리마인더 오프셋 충돌**: 목록을 병합하되 중복 offset은 제거합니다. 동기화 후 `ReminderOrchestrator.ensureScheduledForTask/Event`를 호출해 새 구성을 재스케줄합니다.

## 4. 사용자 피드백
- 충돌 발생 시 앱 내 알림 센터와 스낵바를 통해 "동기화 충돌이 해결되었습니다" 또는 "다른 기기와 일정이 달라졌습니다" 메시지를 제공합니다.
- 세부 정보는 `docs/progress-audit.md`에서 다루는 히스토리 패널에 누적합니다.

## 5. 테스트 전략
- 단위 테스트: `ReminderOrchestrator.ensureScheduledForTask/Event`와 동기화 머지 로직에 대해 재부팅/네트워크 전환/외부 소스 수신 케이스를 모의 객체로 검증합니다.
- 통합 테스트: WorkManager/AlarmManager 기반 스케줄러와 서버 모킹 계층을 결합해 대량 동기화 시 지연/재시도 로직을 확인합니다.
- 회귀 방지: 충돌 해결 시나리오를 Given-When-Then 형식의 시나리오 테스트로 캡처하여 QA 자동화에 포함합니다.

이 전략 문서는 `docs/architecture.md`와 함께 관리하며, 구현 세부 사항이 확정되면 서버 동기화 모듈의 ADR(Architecture Decision Record)로 승격합니다.
